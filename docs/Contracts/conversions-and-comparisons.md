# Conversions & Comparisons — Core Contract

## 1. Общая модель
Тип UDouble представляет односкалярное нормальное распределение с параметрами Mean и Variance. Все операции преобразования и сравнения определяются на уровне средних значений, без использования Variance в операторах сравнения. Цель документа — зафиксировать правила, которые остаются стабильными во всех языках и реализациях.

## 2. Политика преобразований

### 2.1 Общие принципы
1. Преобразование UDouble → double является явным и приводит к потере информации (возвращается Mean).
2. Преобразование числовых типов в UDouble всегда явное.  
   Мотив: создание UDouble — это статистическая операция, которая не должна происходить неявно.
3. Все фабрики должны использовать явные вызовы:
   - UDouble.FromMeanVar(mean, variance)
   - UDouble.FromMeanStd(mean, stdDev)
   - UDouble.FromDouble(x)
   - UDouble.FromFloat(x)
   - UDouble.FromInt(x)
   - UDouble.FromSample(IEnumerable<double> data)
   - UDouble.FromSample(IEnumerable<UDouble> data) с учётом их дисперсий.

### 2.2 Правила explicit-преобразований
Следующие операции существуют и являются explicit:

(UDouble)double  
(UDouble)float  
(UDouble)int  
(double)UDouble   // возвращает Mean

Пример использования:
var x = (UDouble)5;
var y = (UDouble)3.14;
var z = (double)x;  // Mean

### 2.3 Обработка NaN и Infinity
UDouble не может быть создан из:
- NaN
- PositiveInfinity
- NegativeInfinity

Логика одинакова для double и float.  
При попытке создать UDouble из таких значений генерируется ArgumentOutOfRangeException.

Причина: нормальное распределение не определено для этих значений, поэтому дальнейшая пропагация становится математически некорректной.

## 3. Политика сравнения

### 3.1 Основной принцип
UDouble сравнивается только по Mean. Variance не участвует ни в одной операции сравнения.  
Цель — согласованность и совместимость с языками, алгоритмами сортировки, min/max и т.п.

### 3.2 Операторы, определённые в UDouble
Определены:
<   →  a.Mean <  b.Mean  
>   →  a.Mean >  b.Mean  
<=  →  a.Mean <= b.Mean  
>=  →  a.Mean >= b.Mean  
==  →  a.Mean == b.Mean  AND  a.Variance == b.Variance  
!=  →  отрицание оператора ==


Здесь Mean — числовое значение без учёта неопределённости.

### 3.3 Почему Variance не участвует в сравнении
1. UDouble предназначен для пропагации неопределённости, а не для выражения “интервального порядка”.
2. Логика “перекрытия интервалов” неоднозначна и не переносима между языками.
3. Сравнение по Mean даёт:
   - тотальный порядок,
   - предсказуемость,
   - согласованность операторов,
   - отсутствие разрывов в семантике.

### 3.4 Соотношение операторов
Так как определены <, >, <=, >= и == по одному принципу (Mean), тип UDouble образует полный порядок.

Пример:
if (a <= b) { ... }  
if (a == b) { ... }  

Эти операции всегда непротиворечивы между собой.

## 4. Поведение при ошибках
1. Конструкторы и фабрики выбрасывают исключение при попытке создать UDouble из NaN/Infinity.
2. При explicit-конверсиях ошибок нет, если значение допустимо.
3. При сравнении значений UDouble не выбрасываются исключения — Mean всегда определён.

## 5. Примеры

var a = (UDouble)5;
var b = UDouble.FromMeanStd(5.0, 0.1);

if (a == b)     // true, так как равны Mean
if (a < b)      // false
if (a <= b)     // true
double x = (double)b;  // Mean

var s = UDouble.FromSample(new[] { 1.0, 2.0, 3.0 });

## 6. Переносимость в другие языки
Та же логика будет применена в:
C++ (класс с explicit-конструкторами)  
Rust (From/Into с явными реализациями)  
Python (UDouble.from_mean_variance и явные касты)  
Java (static factory methods, без implicit вообще)

Тип остаётся строго детерминированным: сравнения по Mean, фабрики явные, NaN/∞ запрещены.

